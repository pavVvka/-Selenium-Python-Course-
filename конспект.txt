
 ссылки на ресурсы, где вы сможете найти дополнительную информацию по использованию Selenium и о тонкостях при работе с ним:

https://stepik.org/lesson/171979/step/1?unit=146657





>>>  Запуск браузера и первый скрипт


В нашем виртуальном окружении запустим интерпретатор python:  

~/environments$ python 



import time

# webdriver это и есть набор команд для управления браузером
from selenium import webdriver

# инициализируем драйвер браузера. После этой команды вы должны увидеть новое открытое окно браузера
driver = webdriver.Chrome()

# команда time.sleep устанавливает паузу в 5 секунд, чтобы мы успели увидеть, что происходит в браузере
time.sleep(5)

# Метод get сообщает браузеру, что нужно открыть сайт по указанной ссылке
driver.get("https://stepik.org/lesson/25969/step/12")
time.sleep(5)

# Метод find_element_by_css_selector позволяет найти нужный элемент на сайте, указав путь к нему.
Способы поиска элементов мы обсудим позже
# Ищем поле для ввода текста
textarea = driver.find_element_by_css_selector(".textarea")

# Напишем текст ответа в найденное поле
textarea.send_keys("get()")
time.sleep(5)

# Найдем кнопку, которая отправляет введенное решение
submit_button = driver.find_element_by_css_selector(".submit-submission")

# Скажем драйверу, что нужно нажать на кнопку. После этой команды мы должны увидеть сообщение о правильном ответе
submit_button.click()
time.sleep(5)

# После выполнения всех действий мы должны не забыть закрыть окно браузера
driver.quit()





Вы можете запустить этот же скрипт из файла. Скачайте файл get_method.py к себе в папку и запустите его. 
Для этого создадим папку selenium_course и скопируем в нее скачанный файл. 
Затем запустим файл в нашем виртуальном окружении.



(Вместо user везде подставляйте имя пользователя в системе) 

При выполнении следующих команд не забудьте изменить путь к вашей пользовательской папке 
вместо C:\Users\user и к папке с загруженным файлом.

Выполните следующие команды в командной строке Windows:

c:\Users\user> mkdir selenium_course

C:\Users\user> copy C:\Users\user\Downloads\get_method.py c:\Users\user\selenium_course

C:\Users\user> environments\selenium_env\Scripts\activate.bat

(selenium_env) C:\Users\user>python c:\Users\user\selenium_course\get_method.py












>>>    Использование порядкового номера дочернего элемента

Еще один способ найти этот элемент:

#posts > .item:nth-child(2) > .title

Псевдо-класс :nth-child(2) — позволяет найти второй по порядку элемент среди дочерних 
элементов для #posts. Затем с помощью конструкции > .title мы указываем, 
что нам нужен элемент .title, родителем которого является найденный ранее элемент .item.






>>>

#moto                     Поиск по ID
article                   Поиск по tag
[title="one-thing"]       Поиск по attribute
[name="moto"]             Поиск по name
.lead                     Поиск по class
article.text-muted.lead   Поиск по составному CSS-селектору 




 


>>>     Поиск элементов с помощью XPath


1. XPath запрос всегда начинается с символа / или //

Символ / аналогичен символу > в CSS-селекторе, а символ // — пробелу. Их смысл:

    el1/el2 — выбирает элементы el2, являющиеся прямыми потомками el1;
    el1//el2 — выбирает элементы el2, являющиеся потомками el1 любой степени вложенности.

Разница состоит в том, что в XPath, когда мы начинаем запрос с символа /,  
мы должны указать элемент, являющийся корнем нашего документа. 
Корнем всегда будет элемент с тегом <html>. Пример: /html/body/header

Мы можем начинать запрос и с символа //. 
Это будет означать, что мы хотим найти всех потомков корневого элемента без указания корневого элемента. 
В этом случае, для поиска того же хедера, мы можем выполнить запрос //header, так как других заголовков у нас нет.

Важно! Такой поиск может быть неоднозначным. 
Например, запрос //div вернет вам все элементы с тегом <div>. 
Избегайте неоднозначных ситуаций, они плохо влияют на здоровье ваших автотестов.



2. Символ [ ] — это команда фильтрации

Если по запросу найдено несколько элементов, то будет произведена фильтрация по правилу, указанному в скобках.

Правил фильтрации очень много:

    по любому атрибуту, будь то id, class, title (или любой другой). 
Например, мы хотим найти картинку с летящим котом, для этого можно выполнить запрос //img[@id='bullet']

    по порядковому номеру. Допустим, мы хотим выбрать вторую по порядку карточку с котом. 
Для этого найдем элемент с классом "row" и возьмем его второго потомка: //div[@class="row"]/div[2]

    по полному совпадению текста. Да, XPath — это единственный способ найти элемент по внутреннему тексту. 
Если мы хотим найти блок текста с котом-Лениным, можно воспользоваться XPath селектором //p[text()="Lenin cat"]. 
Такой селектор вернет элемент, только если текст полностью совпадет. 
Здесь важно сказать, что не всегда поиск по тексту — это хорошая практика, особенно в случае мультиязычных сайтов.

    по частичному совпадению текста или атрибута. Для этого нужна функция contains. 
Запрос //p[contains(text(), "cat")] вернет нам все абзацы текста, которые содержат слово cat. 
Точно так же можно искать по частичному совпадению других атрибутов, это удобно, если у элемента несколько классов. 
Посмотрите на код навбара сайта с котами. Его можно найти селектором //div[contains(@class, "navbar")]

    в фильтрации еще можно использовать булевы операции (and, or, not) и некоторые простые арифметические выражения 
(но вообще не стоит, наверное). Допустим, мы хотим найти картинку обязательно с data-type "animal" и именем "bullet-cat", 
для этого подойдет запрос: //img[@name='bullet-cat' and @data-type='animal']


