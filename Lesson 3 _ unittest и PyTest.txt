https://stepik.org/lesson/36285/step/1?unit=162401

В качестве основы для данного урока мы адаптировали руководство про написание юнит-тестов в Python:
https://realpython.com/python-testing/


тестовые фреймворки unittest и PyTest:
- позволяют создавать легко читаемые проверки ожидаемых результатов в тестах, 
- удобно настраивать запуск большого количества тестов в нужных окружениях, 
- организовывать хранение тестов и генерацию отчётов для последующего анализа.




Ручные тесты в идеальном случае остаются только на этапе проверки новых фич и в виде исследовательского 
тестирования, которое позволяет найти проблемы в сложных пользовательских сценариях.

Автотесты помогают отделу тестирования оптимизировать свою работу, чтобы сделать счастливее пользователей, 
которые быстрее получают новые фичи и меньше страдают от ошибок в продукте, 
так как разработчики раньше узнают о багах и могут заранее принять меры для их устранения, 
не откладывая релиз продукта.



***
Все никак не спрошу. Немного не по теме:

Почему у меня есть строка DevTools, а у других нет? 


Добавьте в функцию которая открывает браузер эти строки:

options = webdriver.ChromeOptions()
options.add_experimental_option('excludeSwitches', ['enable-logging'])
browser = webdriver.Chrome(options=options)








СОДЕРЖАНИЕ:
===========    Юнит-тесты и интеграционные тесты   ========================
===========    Структура теста   ===========================
===========    Проверка ожидаемого результата  ========================
===========    Тестовые сценарии   =======================

======    unittest   =================================
======    Тестирование с помощью PyTest          ========================
======    Фиксируем пакеты в requirements.txt    ===========================
======    PyTest: правила запуска тестов  ===============================
======    PyTest — отчёты         ======================================
======    PyTest — как пишут тесты    ======================================
======    PyTest — проверка ожидаемого результата (assert)    ================

===========================   3.4 Использование фикстур в PyTest    =============================
===========================   Фикстуры, возвращающие значение    ==============================
===========================   Финализаторы — закрываем браузер   ====================
===========================   Область видимости scope    ==================================
===========================   Автоиспользование фикстур    =======================================


======================   3.5 PyTest — маркировка тестов часть 1   ======================================
===================   Маркировка тестов часть 2   ======================================
===================   Пропуск тестов    ========================================
===================   XFail: помечать тест как ожидаемо падающий   ======================


======================   3.6 PyTest — параметризация, конфигурирование, плагины   =====================
===================    Conftest.py — конфигурация тестов   =================================
===================    Conftest.py и передача параметров в командной строке    ===================
===================    Плагины и перезапуск тестов     ====================================
===================    Полезные ссылки   ==================================================






===========    Юнит-тесты и интеграционные тесты   ========================

Пирамида тестов на практике:
https://habr.com/ru/post/358950/



Юнит-тесты проверяют очень маленький кусок кода, обычно конкретную функцию, и чаще всего их пишут разработчики, 
которые хорошо понимают возможные крайние случаи для своего стека технологий.
- всегда автоматизированы, так как проверяют непосредственно работу кода.



Интеграционные тесты проверяют взаимодействие сразу нескольких систем. Они могут создаваться и поддерживаться 
как разработчиками и тестировщиками, так и аналитиками (если для них разработан удобный фреймворк для написания тестов).
- могут быть ручными и автоматизированными. 


Иногда выделяют отдельную категорию end-to-end (е2е) тестов, которые проверяют полный стек технологий 
приложения и пользовательский сценарий взаимодействия с приложением как с черным ящиком.



UI-тесты, которые разрабатываются с помощью Selenium, их стоит отнести к разряду end-to-end тестов, 
так как они проверяют совместную работу всех систем web-продукта: 
работу frontend и backend, работу базы данных, дополнительные сервисы, такие как аналитика, платежные системы и так далее. 




=================    Структура теста   ===========================


Для написания UI-тестов можно использовать те же возможности Python, что и для написания юнит-тестов, которые создаются разработчиками. 

Любой тест должен содержать:

  1  Входные данные.
  2  Тестовый сценарий, то есть набор шагов, которые надо выполнить для получения результата.
  3  Проверка ожидаемого результата.




==================   Проверка ожидаемого результата  ========================


Для этого используется встроенная в Python инструкция assert, которая проверяет истинность утверждений. 
assert True не приводит к выводу дополнительных сообщений, 
assert False вызовет исключение AssertionError.


>>> assert abs(-42) == -42

AssertionError


Для добавления дополнительного сообщения можно при вызове assert через запятую написать нужное сообщение, 
которое будет выведено в случае ошибки проверки результата:

>>> assert abs(-42) == -42, "Should be absolute value of a number"

>>> assert "login" in browser.current_url, # сообщение об ошибке



---- Задание:  
Функция должна проверить вхождение строки substring в строку full_string с помощью оператора assert и, 
в случае несовпадения, предоставить исчерпывающее сообщение об ошибке. 

def test_substring(full_string, substring):
    # ваша реализация, напишите assert и сообщение об ошибке
    assert substring in full_string, f"expected '{substring}' to be substring of '{full_string}'"



===================   Тестовые сценарии   =======================


Созданные тесты нужно сохранить в файле, чтобы его было удобно запускать и хранить в системе контроля версий. 



создадим файл test_abs_project.py :
ef test_abs1():
    assert abs(-42) == 42, "Should be absolute value of a number"

def test_abs2():
    assert abs(-42) == -42, "Should be absolute value of a number"

if __name__ == "__main__":
    test_abs1()
    test_abs2()
    print("Everything passed")

Мы поместили тестовый сценарий в функцию для разделения тест-кейсов и возможности их независимого запуска.

Не вдаваясь в подробности, скажем только, что конструкция if __name__ == "__main__" служит для подтверждения 
того, что данный скрипт был запущен напрямую, а не вызван внутри другого файла в качестве модуля. 

В приведенном примере мы уже не увидим сообщение "Everything passed", 
так как падение любого теста вызывает выход из программы



 минусы такого подхода к запуску автотестов:

    - Когда тестов становится много, сложно становится запускать только тесты из нужных тест-сьютов.
    - Для каждого теста нужно создавать тестовые данные и окружение отдельно. Например, если мы захотим для каждого теста запускать браузер, а после завершения теста браузер закрывать, то логику работы с браузером придется дублировать в коде каждого теста.
    - Если один из тестов завершится с ошибкой, например, тест упадёт с ошибкой AssertionError, то последующие тесты не запустятся. Мы не узнаем, были ли проблемы в этих тестах, пока не починим упавший тест или пока не запустим эти тесты по отдельности.


-------------------------------------------------------------------------

специальные фреймворки, которые называются test runners (тест-раннеры):

три основных тестовых фреймворка для Python: unittest, PyTest и nose. 

Модуль unittest является встроенным инструментом Python — и это его большой плюс. 


PyTest и nose устанавливаются дополнительно, они позволяют получить расширенные возможности по сравнению с unittest. 




================================================================================================

=======================    unittest   =================================
https://stepik.org/lesson/36285/step/12?unit=162401


Тест-раннеры сами находят тестовые методы в указанных при запуске файлах, но для этого нужно следовать 
общепринятым правилам. 

Общее правило для всех фреймворков: 
название тестового метода должно начинаться со слова "test_". Дальше может идти любой текст, который является уникальным названием для теста:




Для unittest существуют собственные дополнительные правила:

   - Тесты обязательно должны находиться в специальном тестовом классе.
   - Вместо assert должны использоваться специальные assertion методы.




тесты, чтобы их можно было запустить с помощью unittest, нам понадобится выполнить следующие шаги:

    - Импортировать unittest в файл: import unittest
    - Создать класс, который должен наследоваться от класса TestCase: class TestAbs(unittest.TestCase):
    - Превратить тестовые функции в методы, добавив ссылку на экземпляр класса self в качестве первого аргумента функции: def test_abs1(self):
    - Изменить assert на self.assertEqual()
    - Заменить строку запуска программы на unittest.main()


import unittest
class TestAbs(unittest.TestCase):
    def test_abs1(self):
        self.assertEqual(abs(-42), 42, "Should be absolute value of a number")
        
    def test_abs2(self):
        self.assertEqual(abs(-42), -42, "Should be absolute value of a number")
        
if __name__ == "__main__":
    unittest.main()





================================================================================================

============================     Тестирование с помощью PyTest          ========================

https://stepik.org/lesson/193188/step/2?unit=167629


PyTest
https://habr.com/ru/post/269759/

https://pytest-docs-ru.readthedocs.io/ru/latest/contents.html


(selenium_env) С:\Users\user\environments>  pip install pytest==5.1.1


+++++
3) PyTest не требует написания дополнительных специфических конструкций в тестах, как того требует unittest (no boilerplate).
4) Для проверок используется стандартный assert из Python.
5) Возможность создания динамических фикстур (специальных функций, которые настраивают тестовые окружения и готовят тестовые данные).
7) Параметризация тестов — для одного теста можно задать разные параметры (тест запустится несколько раз с разными тестовыми данными).
8) Наличие маркировок (marks), которые позволяют маркировать тесты для их выборочного запуска.
9) Возможность передавать дополнительные параметры через командную строку для настройки тестовых окружений.





===============================    Фиксируем пакеты в requirements.txt    ===========================


зафиксируем все пакеты, которые мы используем

Откройте терминал, перейдите в директорию, в которой вы работаете с автотестами, и активируйте виртуальное окружение.

После чего выполните в терминале команду:

pip freeze > requirements.txt
Эта команда сохранит все версии пакетов в специальный файл requirements.txt.


Как их оттуда достать В новое виртуальное окружение:
pip install -r requirements.txt






===============================  PyTest: правила запуска тестов  ===============================

https://docs.pytest.org/en/stable/goodpractices.html#conventions-for-python-test-discovery



pytest, тест-раннер собирает все тесты для запуска по определенным правилам:

    - если мы не передали никакого аргумента в команду, а написали просто pytest, тест-раннер начнёт поиск в текущей директории

    - как аргумент можно передать файл, путь к директории или любую комбинацию директорий и файлов, например: 

pytest scripts/selenium_scripts
# найти все тесты в директории scripts/selenium_scripts

pytest test_user_interface.py
# найти и выполнить все тесты в файле 

pytest scripts/drafts.py::test_register_new_user_parametrized
# найти тест с именем test_register_new_user_parametrized в указанном файле в указанной директории и выполнить 

    - дальше происходит рекурсивный поиск: то есть PyTest обойдет все вложенные директории

    - во всех директориях PyTest ищет файлы, которые удовлетворяют правилу  test_*.py или *_test.py (то есть начинаются на test_ или заканчиваются _test и имеют расширение .py)

    - внутри всех этих файлов находит тестовые функции по следующему правилу:

        - все тесты, название которых начинается с test, которые находятся вне классов

        - все тесты, название которых начинается с test внутри классов, имя которых начинается с Test (и без метода __init__ внутри класса)






==================================    PyTest — отчёты         ======================================


запустить PyTest с параметром -v (verbose, то есть подробный), 
то в отчёт добавится дополнительная информация со списком тестов и статусом их прохождения


Другие полезные команды для манипуляции выводом тестов PyTest можно найти по ссылке:
https://gist.github.com/amatellanes/12136508b816469678c2




==================================   PyTest — как пишут тесты    ======================================



def test_abs1():
    assert abs(-42) == 42, "Should be absolute value of a number"

def test_abs2():
    assert abs(-42) == -42, "Should be absolute value of a number"

Запустим тесты в этом файле:

pytest test_abs.py





===================================   PyTest — проверка ожидаемого результата (assert)    ================


Если вы используете unittest, то для проверки ожидаемых результатов в тестах вам нужно знать и использовать 
большой набор assert-методов, например, таких: assertEqual, assertNotEqual, assertTrue, assertFalse и другие:
https://docs.python.org/3/library/unittest.html#assert-methods%EF%BB%BF


В PyTest используется стандартный assert метод из языка Python, что делает код более очевидным.



unittest:

self.assertEqual(a, b, msg="Значения разные")

PyTest:

assert a == b, "Значения разные"







=================================================================================================


===========================   3.4 Использование фикстур в PyTest    =============================

https://stepik.org/lesson/237257/step/1?unit=209645



Дополнительные материалы про фикстуры, которые мы настоятельно советуем почитать, приведены ниже:

https://habr.com/ru/company/yandex/blog/242795/

https://docs.pytest.org/en/stable/fixture.html

----------------------------------------------------------------------------------------------------

Фикстуры в контексте PyTest — это вспомогательные функции для наших тестов, 
которые не являются частью тестового сценария.



фикстуры можно использовать для самых разных целей: для подключения к базе данных, с которой работают тесты, 
создания тестовых файлов или подготовки данных в текущем окружении с помощью API-методов. 


Классический способ работы с фикстурами — создание setup- и teardown-методов в файле с тестами
https://docs.pytest.org/en/latest/how-to/xunit_setup.html?highlight=teardown

Можно создавать фикстуры для модулей, классов и отдельных функций



Будем сразу объединять наши тесты в тест-сьюты, роль тест-сьюта будут играть классы, 
в которых мы будем хранить наши тесты.


pytest -s test_fixture1.py    параметр -s, чтобы увидеть текст, который выводится командой print().


----------------------------------------------------------
базовый подход к созданию фикстур - тестовые данные задаются и очищаются в setup и teardown методах:

- браузер запустится один раз:

class TestMainPage1():

    @classmethod
    def setup_class(self):
        print("\nstart browser for test suite..")
        self.browser = webdriver.Chrome()

    @classmethod
    def teardown_class(self):
        print("quit browser for test suite..")
        self.browser.quit()


- браузер запустится два раза:

class TestMainPage2():

    def setup_method(self):
        print("start browser for test..")
        self.browser = webdriver.Chrome()

    def teardown_method(self):
        print("quit browser for test..")
        self.browser.quit()



* лучше всего запускать отдельный браузер для каждого теста, чтобы тесты были стабильнее. 







===========================    Фикстуры, возвращающие значение    ==============================


PyTest предлагает продвинутый подход к фикстурам, когда фикстуры можно задавать глобально, 
передавать их в тестовые методы как параметры, а также имеет набор встроенных фикстур.



Фикстуры могут возвращать значение, которое затем можно использовать в тестах.


Мы создадим фикстуру browser, которая будет создавать объект WebDriver. 


@pytest.fixture
def browser():
    print("\nstart browser for test..")
    browser = webdriver.Chrome()
    return browser


class TestMainPage1():
    # вызываем фикстуру в тесте, передав ее как параметр
    def test_guest_should_see_login_link(self, browser):
        browser.get(link)
        browser.find_element_by_css_selector("#login_link")




====================================   Финализаторы — закрываем браузер   ====================



Один из вариантов финализатора — использование ключевого слова Python: yield. 

После завершения теста, который вызывал фикстуру, выполнение фикстуры продолжится со строки, 
следующей за строкой со словом yield:



@pytest.fixture
def browser():
    print("\nstart browser for test..")
    browser = webdriver.Chrome()
    yield browser
    # этот код выполнится после завершения теста
    print("\nquit browser..")
    browser.quit()



Есть альтернативный способ вызова teardown кода с помощью встроенной фикстуры request и ее метода addfinalizer. 
Можете изучить его сами по документации PyTest. 

https://docs.pytest.org/en/latest/how-to/fixtures.html#adding-finalizers-directly


Рекомендуем также выносить очистку данных и памяти в фикстуру, вместо того чтобы писать это в шагах теста: 
финализатор выполнится даже в ситуации, когда тест упал с ошибкой. 





==================================     Область видимости scope    ==================================


Для фикстур можно задавать область покрытия фикстур. 
Допустимые значения: “function”, “class”, “module”, “session”. 


Соответственно, фикстура будет вызываться: 
- один раз для тестового метода, 
- один раз для класса, 
- один раз для модуля или один раз для всех тестов, запущенных в данной сессии.



Запустим все наши тесты из класса TestMainPage1 в одном браузере для экономии времени, 
задав scope="class" в фикстуре browser:


@pytest.fixture(scope="class")

в данном примере браузер открылся один раз и тесты последовательно выполнились в этом браузере. 
Здесь мы проделали это в качестве примера, но мы крайне рекомендуем всё же запускать отдельный экземпляр браузера для каждого теста, 




==================================   Автоиспользование фикстур    =======================================


дополнительный параметр autouse=True, который укажет, 
что фикстуру нужно запустить для каждого теста даже без явного вызова: 


@pytest.fixture(autouse=True)

для каждого теста фикстура подготовки данных выполнилась без явного вызова. 
Нужно быть аккуратнее с этим параметром, потому что фикстура выполняется для всех тестов. 
Без явной необходимости автоиспользованием фикстур лучше не пользоваться. 






========================================================================================================

======================   3.5 PyTest — маркировка тестов часть 1   ======================================


https://stepik.org/lesson/236918/step/2?unit=209305

В чём разница Smoke, Sanity, Regression, Re-test и как их различать?
https://habr.com/ru/post/358142/


по каким-нибудь заданным нами категориям:

- выбрать небольшое количество критичных тестов (smoke), которые нужно запускать на каждый коммит разработчиков
- регрессионные (regression) и запускать их только перед релизом. 
- специфичные для конкретного браузера (internet explorer 11), и мы хотим запускать эти тесты только под данный браузер.



Для выборочного запуска таких тестов в PyTest используется маркировка тестов или метки (marks). 

Для маркировки теста нужно написать декоратор вида @pytest.mark.mark_name, где mark_name — произвольная строка.



Чтобы запустить тест с нужной маркировкой, нужно передать в командной строке параметр -m и нужную метку:

pytest -s -v -m smoke test_fixture8.py



import pytest
from selenium import webdriver

link = "http://selenium1py.pythonanywhere.com/"


@pytest.fixture(scope="function")
def browser():
    print("\nstart browser for test..")
    browser = webdriver.Chrome()
    yield browser
    print("\nquit browser..")
    browser.quit()


class TestMainPage1:
    @pytest.mark.smoke
    def test_guest_should_see_login_link(self, browser):
        browser.get(link)
        browser.find_element_by_css_selector("#login_link")

    @pytest.mark.regression
    def test_guest_should_see_basket_link_on_the_main_page(self, browser):
        browser.get(link)
        browser.find_element_by_css_selector(".basket-mini .btn-group > a")




предупреждение PytestUnknownMarkWarning: появилось потому, что 
в последних версиях PyTest настоятельно рекомендуется регистрировать метки явно перед использованием

------------------  Как же регистрировать метки?


Создайте файл pytest.ini в корневой директории вашего тестового проекта и добавьте в файл следующие строки:

[pytest]
markers =
    smoke: marker for smoke tests
    regression: marker for regression tests

Текст после знака ":" является поясняющим — его можно не писать.


Так же можно маркировать целый тестовый класс. 
В этом случае маркировка будет применена ко всем тестовым методам, входящим в класс.






===================================   Маркировка тестов часть 2   ======================================

>  Инверсия

Чтобы запустить все тесты, не имеющие заданную маркировку (инверсия)

pytest -s -v -m "not smoke" test_fixture8.py


>  Объединение тестов с разными маркировками

Для запуска тестов с разными метками можно использовать логическое ИЛИ. Запустим smoke и regression-тесты:

pytest -s -v -m "smoke or regression" test_fixture8.py


>  Выбор тестов, имеющих несколько маркировок

Предположим, у нас есть smoke-тесты, которые нужно запускать только для определенной операционной системы, например, для Windows 10. Зарегистрируем метку win10 в файле pytest.ini, а также добавим к одному из тестов эту метку.

pytest.ini:

[pytest]
markers =
    smoke: marker for smoke tests
    regression: marker for regression tests
    win10


@pytest.mark.smoke
    @pytest.mark.win10
    def test_guest_should_see_basket_link_on_the_main_page(self, browser):
        browser.get(link)
        browser.find_element_by_css_selector(".basket-mini .btn-group > a")




Чтобы запустить только smoke-тесты для Windows 10, нужно использовать логическое И:

pytest -s -v -m "smoke and win10" test_fixture81.py

Должен выполнится тест test_guest_should_see_basket_link_on_the_main_page. 





==========================   Пропуск тестов    ========================================


В PyTest есть стандартные метки, которые позволяют пропустить тест при сборе тестов для запуска 
(то есть не запускать тест) или запустить, но отметить особенным статусом тот тест, 
который ожидаемо упадёт из-за наличия бага, чтобы он не влиял на результаты прогона всех тестов. 

Эти метки не требуют дополнительного объявления в pytest.ini.

чтобы пропустить тест, его отмечают в коде как @pytest.mark.skip:



Если маркировка skip добавляется к функции, где уже есть другие маркировки, 

то skip должен быть последним маркером, иначе пропускаться не будет.
 
@pytest.mark.regression
@pytest.mark.win10
@pytest.mark.skip 



Также можно добавить строку "addopts = --strict-markers"  в pytest.ini, 
благодаря ей при указании маркера отсутствующего в файле мы будем проинформированы ошибкой.

[pytest]

addopts = --strict-markers

markers =

    smoke: marker for smoke tests

    regression: marker for regression tests

    win 10: only for win10 OS




Еще для пропущенного теста можно оставлять комментарий. 

Например, @pytest.mark.skip(reason="Reason to skip test"). 




==========================   XFail: помечать тест как ожидаемо падающий   ======================


https://pytest.org/en/stable/skipping.html
есть много разных интересных особенностей, например, как пропускать тест только при выполнении условия, 
как сделать так, чтобы внезапно прошедший xfailed тест в отчете стал красным, и так далее. 


Документация про маркировку xfail :
https://docs.pytest.org/en/latest/reference/reference.html?highlight=xfail#pytest.mark.xfail



>  Отметить тест как падающий


проверяет наличие кнопки "Избранное":

Предположим, что такая кнопка должна быть, но из-за изменений в коде она пропала. 
Пока разработчики исправляют баг, мы хотим, чтобы результат прогона ﻿всех ﻿наших тестов был успешен, 
но падающий тест помечался соответствующим образом, чтобы про него не забыть.

Добавим маркировку @pytest.mark.xfail для падающего теста.



Запустим наши тесты:

pytest -v test_fixture10.py

Наш упавший тест теперь отмечен как xfail, но результат прогона тестов помечен как успешный


Когда баг починят, мы это узнаем, ﻿﻿так как теперь тест будет отмечен как XPASS 
(“unexpectedly passing” — неожиданно проходит). 
После этого маркировку xfail для теста можно удалить. 

Кстати, к маркировке xfail можно добавлять параметр reason. 
Чтобы увидеть это сообщение в консоли, при запуске нужно добавлять параметр pytest -rx.


@pytest.mark.xfail(reason="fixing this bug right now")


pytest -rx -v test_fixture10a.py





>  XPASS-тесты

Поменяем селектор в последнем тесте, чтобы тест начал проходить.


Запустите тесты. Здесь мы добавили символ X в параметр -r, чтобы получить подробную информацию по XPASS-тестам:

pytest -rX -v test_fixture10b.py




****
-r chars              show extra test summary info as specified by chars:

                        (f)ailed, (E)rror, (s)kipped, (x)failed, (X)passed,

                        (p)assed, (P)assed with output, (a)ll except passed (p/P), or (A)ll. 

                        Warnings are displayed at all times except when --disable-warnings is set.

****

Документация про маркировку xfail:

https://docs.pytest.org/en/latest/reference/reference.html?highlight=xfail#pytest.mark.xfail


сondition - (условие) - условие при котором тестовая функция помечается как xfail (не работающая) , принимает либо булево значение либо строку, при булевом значении, нужно будет указать дополнительный параметр reason(причина)

reason - (причина) - причина по которой фунция помечена как xfail, принимается строка

raises - (выбрасывания исключений) подкласс исключений которые ожидаются при вызове теста, другие исключения завалят тест

run - (запуск) - параметр отвечающий за запуск теста, при значении False будет всегда xfail и не будет запускаться. принимается булевы значения


strict - (строгость) значение False по умолчанию,  в выводе терминала  будет xfailed, 
- если функция провалила тест и xpass, если прошла. при значении True в выводе терминала будет xfailed, 
- если функция не прошла тест, но если фунцкция неожиданно прошла тест то будет fail

****





===========================   3.6 PyTest — параметризация, конфигурирование, плагины   =====================

https://stepik.org/lesson/237240/step/1?unit=209628


How to parametrize fixtures and test functions
https://docs.pytest.org/en/latest/how-to/parametrize.html?highlight=parametrize




В @pytest.mark.parametrize() 
нужно передать параметр, который должен изменяться, и список значений параметра. 
В самом тесте наш параметр тоже нужно передавать в качестве аргумента. 
-- внутри декоратора имя параметра оборачивается в кавычки, 
-- в списке аргументов теста кавычки не нужны.



сайт доступен для разных языков:

@pytest.mark.parametrize('language', ["ru", "en-gb"])
def test_guest_should_see_login_link(browser, language):
    link = f"http://selenium1py.pythonanywhere.com/{language}/"
    browser.get(link)
    browser.find_element_by_css_selector("#login_link")




Можно задавать параметризацию также для всего тестового класса, 
чтобы все тесты в классе запустились с заданными параметрами.

@pytest.mark.parametrize('language', ["ru", "en-gb"])
class TestLogin:
    def test_guest_should_see_login_link(self, browser, language):
        link = f"http://selenium1py.pythonanywhere.com/{language}/"
        browser.get(link)
        browser.find_element_by_css_selector("#login_link")
        # этот тест запустится 2 раза

    def test_guest_should_see_navbar_element(self, browser, language):
        # этот тест тоже запустится дважды




=============================    Conftest.py — конфигурация тестов   =================================



Создадим файл conftest.py в корневом каталоге нашего тестового проекта и перенесем туда фикстуру browser:

import pytest
from selenium import webdriver

@pytest.fixture(scope="function")
def browser():
    browser = webdriver.Chrome()
    yield browser
    browser.quit()

Теперь, сколько бы файлов с тестами мы ни создали, у тестов будет доступ к фикстуре browser. 
Фикстура передается в тестовый метод в качестве аргумента. 
Таким образом можно удобно переиспользовать одни и те же вспомогательные функции в разных частях проекта.

PyTest автоматически находит и подгружает файлы conftest.py, которые находятся в директории с тестами. 
Если вы храните все свои скрипты для курса в одной директории, будьте аккуратны и следите, 
чтобы не возникало ситуации, когда вы запускаете тесты из папки tests:

tests/
├── conftest.py
├── subfolder
│   └── conftest.py
│   └── test_abs.py

следует избегать!    Таким образом можно переопределять разные фикстуры






=================    Conftest.py и передача параметров в командной строке    ===================

https://stepik.org/lesson/237240/step/6?unit=209628



настраивать тестовые окружения с помощью передачи параметров через командную строку:


с помощью встроенной функции pytest_addoption и фикстуры request. 
Сначала добавляем в файле conftest обработчик опции в функции pytest_addoption, 
затем напишем фикстуру, которая будет обрабатывать переданные в опции данные. 
Подробнее можно ознакомиться здесь: 
https://docs.pytest.org/en/latest/example/simple.html?highlight=addoption


1) request- объект для анализа контекста запрашивающей тестовой функции, класса или модуля.
2) parser - атрибут объекта request.
3) атрибут action (по умолчанию: "store") - определяет действие для заданной в командной строке опции. 
За опцией должен следовать аргумент, который будет конвертирован в значение и сохранен. 
store_true и store_false - это специальные случаи, когда сохраняется значение True или False. 


conftest.py:

import pytest
from selenium import webdriver

def pytest_addoption(parser):
    parser.addoption('--browser_name', action='store', default=None,
                     help="Choose browser: chrome or firefox")


@pytest.fixture(scope="function")
def browser(request):
    browser_name = request.config.getoption("browser_name")
    browser = None
    if browser_name == "chrome":
        print("\nstart chrome browser for test..")
        browser = webdriver.Chrome()
    elif browser_name == "firefox":
        print("\nstart firefox browser for test..")
        browser = webdriver.Firefox()
    else:
        raise pytest.UsageError("--browser_name should be chrome or firefox")
    yield browser
    print("\nquit browser..")
    browser.quit()





test_parser.py:

link = "http://selenium1py.pythonanywhere.com/"


def test_guest_should_see_login_link(browser):
    browser.get(link)
    browser.find_element_by_css_selector("#login_link")




Если вы теперь запустите тесты без параметра, то получите ошибку:

pytest -s -v test_parser.py

_pytest.config.UsageError: --browser_name should be chrome or firefox



параметр по умолчанию, чтобы в командной строке не обязательно было указывать параметр --browser_name, 
например, так:

parser.addoption('--browser_name', action='store', default="chrome",
                 help="Choose browser: chrome or firefox")




А теперь запустим тесты на Firefox:

pytest -s -v --browser_name=firefox test_parser.py






==============================    Плагины и перезапуск тестов     ====================================



https://docs.pytest.org/en/latest/explanation/flaky.html?highlight=plugins#plugins


https://docs.pytest.org/en/latest/reference/plugin_list.html




Flaky-тесты или "мигающие" авто-тесты, т.е. такие тесты, которые по независящим от нас внешним обстоятельствам 
или из-за трудновоспроизводимых багов, могут иногда падать, хотя всё остальное время они проходят успешно.


Поэтому мы будем перезапускать упавший тест, чтобы еще раз убедиться, что он действительно нашел баг, 
а не упал случайно.

Это сделать очень просто. Для этого мы будем использовать плагин pytest-rerunfailures.


pip install pytest-rerunfailures



"--reruns n", где n — это количество перезапусков. Если при повторных запусках тесты пройдут успешно, 
то и прогон тестов будет считаться успешным. 
Количество перезапусков отображается в отчёте, благодаря чему можно позже анализировать проблемные тесты.﻿﻿
Дополнительно мы указали параметр "--tb=line", чтобы сократить лог с результатами теста. 
Можете почитать подробнее про настройку вывода в документации PyTest:

https://docs.pytest.org/en/stable/usage.html#modifying-python-traceback-printing



pytest -v --tb=line --reruns 1 --browser_name=chrome test_rerun.py







======================================    Запуск автотестов для разных языков интерфейса    ===================


Цель: научиться запускать автотесты для разных локалей, т.е. для разных языков интерфейсов.



Давайте сделаем так, чтобы сервер сам решал, какой язык интерфейса нужно отобразить,основываясь на данных браузера. 
Браузер передает данные о языке пользователя через запросы к серверу, 
указывая в Headers (заголовке запроса) параметр accept-language. 
Если сервер получит запрос с заголовком {accept-language: ru, en}, 
то он отобразит пользователю русскоязычный интерфейс сайта. 
Если русский язык не поддерживается, то будет показан следующий язык из списка, 
в данном случае пользователь увидит англоязычный интерфейс.



Чтобы указать язык браузера с помощью WebDriver, используйте класс Options и метод add_experimental_option :
(это экспериментальная функция, которая нужна для управления тем, 
какие языки запрашиваются для страницы и один из её параметров)


from selenium.webdriver.chrome.options import Options

options = Options()
options.add_experimental_option('prefs', {'intl.accept_languages': user_language})
browser = webdriver.Chrome(options=options)



Для Firefox объявление нужного языка будет выглядеть немного иначе:

fp = webdriver.FirefoxProfile()
fp.set_preference("intl.accept_languages", user_language)
browser = webdriver.Firefox(firefox_profile=fp)




В конструктор webdriver.Chrome или webdriver.Firefox вы можете добавлять разные аргументы, 
расширяя возможности тестирования ваших веб-приложений: можно указывать прокси-сервер для контроля 
сетевого трафика или запускать разные версии браузера, указывая локальный путь к файлу браузера.





***
add_experimental_option(name, value)
Adds an experimental option which is passed to chrome.

Args: name: The experimental option name. value: The option value.

При запуске браузера мы указываем, какие возможности драйвер должен поддерживать. 
Это может включать в себя настройки профиля для браузера или любые другие возможности.
Однако, одна из проблем этой модели заключается в том, что она реализована 
в виде словаря с парами ключ-значение, состоящими из ключей, которые являются произвольными строками и значений,
которые являются объектами произвольного типа. Здесь есть две потенциальные проблемы. 
Во-первых, имена возможностей легко забыть, во вторых они могут не поддерживаться всеми браузерами.
Чтобы пользователи не блокировались от использования новой возможности до тех пор, 
пока не будет выпущена следующая версия Selenium, в классах параметров есть "добавить дополнительную опцию, 
для которой еще нет способа установки типа безопасности". 
В Python этот метод называется add_experimental_option. 
Этот метод, как правило, предназначен для временного использования, пока проект Selenium не сможет 
подтолкнуть новый релиз, который включает в себя безопасный тип, для любой новой опции, добавленной в драйвер.


***




===============   Полезные ссылки   ==================================================


https://stepik.org/lesson/237258/step/1?unit=209646




















